#!/usr/bin/env perl
use strict;
use warnings;
use Log::Log4perl;
use Getopt::Long;
#use DatabaseFunc;
use Celgene::Utils::FileFunc;
use Celgene::Utils::ArrayFunc;
use Time::localtime;
use File::stat;
use File::Basename;
use File::Find;
use FindBin;
use lib $FindBin::RealBin."/lib";
use Data::Dumper;
use MetadataPrepare;
use fileObj;
use Frontier::Client;
use Data::Dumper;

my $port;
if(defined($ENV{NGS_SERVER_PORT})){ 
	$port= $ENV{NGS_SERVER_PORT};
}else{ 
	die "Cannot find the port to contact the NGS server\n".
	    "This is set from the \$NGS_SERVER_PORT environment variable\n".
		"Is it set in the configuration files?\n";
}

my $ip;
if(defined($ENV{NGS_SERVER_IP})){ 
	$ip= $ENV{NGS_SERVER_IP};
}else{ 
	die "Cannot find the IP of the NGS server.\n".
		"This is set from the \$NGS_SERVER_IP environment variable\n".
		"Is it set in the configuration files?\n";
}
my $server_url = "http://".$ip.":".$port."/RPC2";
my $server = Frontier::Client->new('url' => $server_url);



my ($logLevel,$logFile,$help,$nocommit,$irodsonly,$ignoremet)=('INFO',undef,undef,undef,undef);
my ($file,$user);
$user=$ENV{USER};
GetOptions(
	"file=s"=>\$file, 
	"metadata!"=>\$irodsonly,
	"loglevel=s"=>\$logLevel,
	"logfile=s"=>\$logFile,
	"help!"=>\$help,
	"ignoremet!"=>\$ignoremet,
	"nocommit!"=>\$nocommit
);
my @outputDirectories;

if(defined($help)){printHelp();exit(0);}
if(!defined($file)){printHelp();exit(1);}
if(!defined($logFile)){$logFile=$file.".log";}
sub printHelp{
	print
	"$0. registers a file in the database and prepares a metadata file for ingestion into the data management system.\n".
	" --file <tab delimited file with information to enter in the database>\n".
	"        this file should be a tab delimited file. Can be generated by the XL template provided at the sharepoint site \n".
	"        (http://teamsites.celgene.com/sites/CompBio/Documents/data.import.xlsx)\n".
	" --metadata will ONLY prepare the file metadata registration, assumes that the sample has been added in the database\n".
	"        use this option if previous metadata registration failed in order to avoid duplicate registrations\n".
	" --ignoremet will not register samples associated with files that have already been processed i.e. there is a .met file for them.\n".
	"             use this option if you have received errors from previous runs of the script for the same import file\n".
	" --logLevel/--logFile standard logger arguments\n".
	" --nocommit Debugging option. Runs the script but does not commit changes to the database\n".
	" --help this screen\n".
	"\n";
}
sub setupLog{
my $logConf=qq{
	log4perl.rootLogger          = $logLevel, Logfile, Screen
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = $logFile
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Logfile.layout.ConversionPattern = [%p : %c - %d] - %m{chomp}%n
    log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.stderr  = 0
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Screen.layout.ConversionPattern = [%p - %d] - %m{chomp}%n
};
Log::Log4perl->init(\$logConf);
my $logger=Log::Log4perl->get_logger("registerData");
return $logger;
}
my $logger=setupLog();
$logger->debug("Connecting to the database");
#my $dbh=DatabaseFunc::connectDB();

$logger->debug("Processing file $file");
my @filelines=loadFile($file);
my ($titlesH,$titlesA)=getTitles( @filelines );
my %titles=%$titlesH;my @titles=@$titlesA;
# load the file in memory
sub loadFile{
	my ($file)=@_;

	my $rfh=Celgene::Utils::FileFunc::newReadFileHandle($file);
	my @filecontent=<$rfh>;
	my $filecontent=join("\n", @filecontent);
	my @filelines=split( /[\r\n]+/, $filecontent );
	close($rfh);
	return @filelines;
}

sub getTitles{
	
	my $titleLine;
	
	for(my $i=0; $i<scalar(@filelines);$i++){
		my $l=shift(@filelines);
		if($l=~/^#/){next;}
		$titleLine=$l ;
		last;
	}
	my @titles=split("\t",$titleLine);
	my %titles;
	
	# modify the titles from the omicsoft names to the pg names
	for(my $i=0;$i<scalar(@titles);$i++){
		my $k=omicssoft2pg( $titles[$i]);
		$titles[$i]=$k;
		$titles{ $k }=$i;
	}
	# add missing titles from the mandatory fields
	my %missingTitles=databaseMandatory();
	foreach my $k( keys %missingTitles){
		if(defined($titles{ $k })){next;}
		push @titles, $k;
		$titles{$k }=scalar( @titles )-1;
	}
	
	$logger->debug("Titles: $titleLine");
	return (\%titles,\@titles);
}


my $lineNumber=0;
while(my $line= shift @filelines){
	$lineNumber ++;
	if($line =~/^#/){next;}
	$logger->debug("Processing : $line");
	my @data=split("\t", $line);	
	
	foreach my $k(keys %titles){
		$k=lc($k);
		my $v;
		if(!defined($data[$titles{$k}])){ $v="NOT PROVIDED";}
		else{$v=$data[$titles{$k}];}
		$logger->debug("$k: ", $v  );
	
	}
	
	# check the if the files are available
	if(!defined($data[$titles{filename}])){
	   	$logger->logdie("This line does not have a filename or points to a file [$data[$titles{filename}]] that does not exist");
	}
	
	$data[$titles{filename}]=~s/"//g;
	my @filenames=split("[,;]", $data[$titles{filename}]);
	$logger->debug("From this line will process \n",join("\n",@filenames));
	my $metFileExists=undef;
	
	for(my $i=0; $i<scalar(@filenames); $i++){
		$logger->debug("Iteration $i. Processing $filenames[$i]");
		
		if(-d $filenames[$i] ){
			$logger->info("File [$filenames[$i]] points to a directory. All the files of the directory will be processed.");
			# get the contents of the directory
			# helper function for the find operation. Used when a directory is provided in the input filename 
			
			find( 
				sub{
					my $fname=$File::Find::name;
					if(!-f $fname or $fname =~/.met$/){ return; }
					$logger->debug("Adding $File::Find::name to the list of files");
					push @filenames, $fname } , 
				$filenames[$i] );
			
			$logger->debug("Finished scanning $filenames[$i]");
			$filenames[$i]=undef;
		}
	}
	#compact filenames (i.e. remove undefined ones which may point to directories)
	@filenames = grep defined, @filenames;
	for(my $i=0; $i<scalar(@filenames); $i++){
		$logger->debug("Iteration $i. Processing $filenames[$i]");
		
		my $fobj=fileObj->new( $filenames[$i] , "regular", "on");
		
		
		if(! -e $fobj->absFilename() and $fobj->absFilename() !~ /^s3:/ ){
			$logger->logdie("File [$filenames[$i]] aka [".$fobj->absFilename()."] does not exist");
		}
		
		my $fileDirectory=dirname( $fobj->absFilename() );
		push @outputDirectories, $fileDirectory;
		
		$filenames[$i]=$fobj;
		if( -e $fobj->absFilename().".met"){
			$metFileExists=1;
		}
		
	}
	

	
	if(defined($metFileExists) and defined( $ignoremet)){ 
		$logger->info("At least one of the files from this sample has already been processed. Skipping this sample (--ignoremet argument)");
		next;
	}
	
	my $sample_id=0; 
	my ($experiment_type, $experimentName,$celgene_project_desc,$celgene_project_name);
	
	if(defined($irodsonly)){
		$logger->info("Will search for existing samples with vendor_id: ". $data[$titles{vendor_id}].
		              " belonging to project ". $data[$titles{celgene_project_desc}] );
		($sample_id, $experiment_type ,$experimentName,$celgene_project_desc, $celgene_project_name)=
			getSampleId( $data[$titles{vendor_id}],$data[$titles{da_project_id}]);
		if(!defined($sample_id) or $sample_id==0){
			$logger->logdie("Cannot find a valid sample id for the sample with vendor id = ".$data[$titles{vendor_id}]);
		}
		$logger->info("Found sample id $sample_id corresponding to vendor id $data[$titles{vendor_id}]. ");
	}else{
	
		# need to break down compounds and doses in order to be placed in the corresponding arrays
		# the user has provided ifnormation in the form Compound1, Dose1, Compound2, Dose2 etc
		# same applies for response_desc and response_array fields
		my @compound_array;
		my @dose_array;
		my @response_desc_array;
		my @response_array;
		for(my $i=0; $i<100; $i++){
			if($i==0){ $i = "";}
			my $l="compound".$i;
			if(defined($titles{ $l })){
				push @compound_array, $data[ $titles{$l} ];
			}
			my $l2="dose".$i;
			if(defined($titles{ $l2 } )){
				push @dose_array, $data[ $titles{$l2} ];
			}
			my $l3="response_desc".$i;
			if(defined($titles{ $l3 } )){
				push @response_desc_array, $data[ $titles{$l3} ];
			}
			my $l4="response".$i;
			if(defined($titles{ $l4 } )){
				push @response_array, $data[ $titles{$l4} ];
			}
		}

		
		#experiment
		if(!defined($data[$titles{"da_project_id"}])){
			$logger->logdie("Please provide an DA number for this project in columne 'DA_project_id'");
		}
		if(!defined($data[$titles{"experiment"}])){
			$logger->logdie("Please provide an experiment description name e.g. FFPE-pilot-001");
		}	
		#experiment_type_cv
		if(!defined($titles{"experiment_type"})){ 
			$logger->logdie("Please provide a column under the name 'experiment_type' with information about sequencing type (e.g. RNA-Seq, ChIP-Seq)");
		}
		($experiment_type, $experimentName)=checkExperimentTypeCV( $data[ $titles{ "experiment_type"  }  ] );
		$logger->debug("Experiment type:$experiment_type, Experiment name (official): $experimentName");
		if($experimentName eq "RNA-Seq" and !defined($titles{ 'rna_selection'})){
			$logger->logdie("Since this is an RNA-Seq experiment you need to provide the RNA selection method used");
		}
		if($experimentName eq 'exome Seq' and !defined($titles{'exome_bait_set'})){
			$logger->logdie("Since this is an exome Seq experiment you need to provide the bait set used");
		}
		#vendor_cv
		my $vendor;
		if(! $data[$titles{vendor}]){ $vendor='DEFAULT';}
		else{$vendor="'".checkVendorCV( $data[ $titles{ "vendor"  }  ])."'";}
		#technology_cv
		if(!defined($titles{"technology"})){ 
			$logger->logdie("Please provide a column under the name 'Technology' with information about sequencing technology or chip version or panel used");
		}
		my $technology=checkTechnologyCV( $data[ $titles{ "technology"  }  ] );
		# library_prep
		if(!defined($titles{"library_prep"})) {
			$logger->logdie("Please provide a column under the name 'library_prep' with information about the sequencing library preparation kit");
		}
		my $library_prep=checkExpTypeCV( $data[ $titles{ "library_prep"}], 'library prep');
		my($rna_selection, $exome_bait_set)=('NULL','NULL');
		if(defined( $titles{exome_bait_set}) and defined($data[ $titles{exome_bait_set}]) and $data[ $titles{exome_bait_set}] ne ""  ){
			$exome_bait_set=checkExpTypeCV( $data[ $titles{ "exome_bait_set" }], 'exome bait set');
		}
		if(defined( $titles{ rna_selection} ) and defined($data[$titles{"rna_selection"}])and $data[ $titles{rna_selection}] ne ""){
			$rna_selection=checkExpTypeCV( $data[ $titles{ "rna_selection" }], 'rna selection');
		}
		
		
		# add information in the table sample_info
		if(! $data[$titles{biological_replicates_group}]){$data[$titles{biological_replicates_group}]='DEFAULT';}
		if(! $data[$titles{technical_replicates_group}] ){$data[$titles{technical_replicates_group}] ='DEFAULT'; }
		if(! $data[$titles{time_treatment}]){ $data[$titles{time_treatment}] = 'DEFAULT';}
		else{ $data[$titles{time_treatment}] = "'$data[$titles{time_treatment}]'";  }
		if(! $data[$titles{xenograft}]){$data[$titles{xenograft}]='DEFAULT';}
		else{$data[$titles{xenograft}]="'$data[$titles{xenograft}]'";}
		
		# project is a single entry for each file
		if(!defined($data[ $titles{ "celgene_project_desc"  }  ]) or 
		   $data[ $titles{ "celgene_project_desc"  }  ] eq ""){
			$logger->logdie("Please specify a celgene project (field: celgene_project_desc)");
		}
		my @synonyms;
		@synonyms =(  split(/[:,]/, $data[ $titles{ "experiment"  }  ]) , split(/[:,]/, $data[ $titles{ "celgene_project_desc"  }  ]) );
		@synonyms=Celgene::Utils::ArrayFunc::unique(\@synonyms);
		my $project_id;
		
		$project_id= getProjectId( $data[ $titles{'da_project_id'}]);
		$logger->info("Project : $project_id is registered to the database");
		#celgene_project_desc_cv		
		
		for (my $p=1; $p<scalar( @synonyms); $p++ ){
			 my $synonym_project_id= getProjectId( $data[$titles{da_project_id}],$synonyms[$p] );
			 
		}
		
		
		
		
		# reference and host genomes
		if(! $data[$titles{reference_genome}]){
			
			$data[$titles{reference_genome}]='Homo sapiens';
			$logger->warn("Since no reference genome provided the default 'Homo sapiens' will be used");
		}
		if( ! $data[$titles{host_genome}] and 
			defined($data[$titles{xenograft}]) and   uc($data[$titles{xenograft}]) eq 'YES'
			 ){
			 	$logger->warn("Since this appears to be a xenograft model and no host genome is provided the default 'Muse musculus' will be used");
			 	$data[$titles{host_genome}]='Mus musculus';
			 }
		foreach my $k( keys( %titles )){
			if(!defined( $data[$titles{ $k } ] ) ){
				$data[$titles{$k}]='NULL';
			}
		}
	
		my $sqlHash={};
		$sqlHash->{vendor_id}=$data[$titles{vendor_id}];
		$sqlHash->{celgene_id}=$data[$titles{celgene_id}];
		$sqlHash->{project_id}=$project_id;
		$sqlHash->{biological_replicates_group}=$data[$titles{biological_replicates_group}];
		$sqlHash->{technical_replicates_group}=$data[$titles{technical_replicates_group}];
		$sqlHash->{cell_line}=$data[$titles{cell_line}];
		$sqlHash->{display_name}=$data[$titles{display_name}];
		# $sqlHash->{response}=$data[$titles{response}];  ## replaced with response_array
		$sqlHash->{cell_type}=$data[$titles{cell_type}];
		$sqlHash->{compound_array}=\@compound_array;
		$sqlHash->{dose_array}=\@dose_array;
		$sqlHash->{time_treatment}=$data[$titles{time_treatment}];
		$sqlHash->{xenograft}=$data[$titles{xenograft}];
		$sqlHash->{reference_genome}=$data[$titles{reference_genome}];
		$sqlHash->{host_genome}=$data[$titles{host_genome}];
		$sqlHash->{tissue}=$data[$titles{tissue}];
		$sqlHash->{condition}=$data[$titles{condition}];
		$sqlHash->{vendor_project_name}=$data[$titles{vendor_project_name}];
		$sqlHash->{ technology}=$technology;
		$sqlHash->{experiment_type}=$experiment_type,
		$sqlHash->{vendor}=$vendor;
		$sqlHash->{antibody}=$data[$titles{antibody}];
		$sqlHash->{antibody_target}=$data[$titles{antibody_target}];
		$sqlHash->{paired_end}=$data[$titles{paired_end}];
		$sqlHash->{stranded}=$data[$titles{stranded}];
		$sqlHash->{response_desc_array}=\@response_desc_array;
		$sqlHash->{response_array}=\@response_array;
		#$sqlHash->{celgene_project_desc_id}=\@celgene_project_desc;
		$sqlHash->{library_prep}= $library_prep;
		
		$sqlHash->{rna_selection}= $rna_selection;
		$sqlHash->{exome_bait_set}= $exome_bait_set;
		validateValues( $sqlHash,$line);
	
	
		# add the remaining data in teh avs
		my %neededColumns=databaseMandatory();
		$sqlHash->{avs}=[];
		for(my $k=0;$k<scalar(@titles);$k++){
			$logger->debug("Checking if $titles[$k] needs to be added in the AV table");
			my $temp=databaseMandatory($titles[$k]);
			if( defined($temp) ){next;}
			push @{$sqlHash->{avs}}, [ $titles[$k], $data[$k]   ];
			$logger->debug("Will be added in the database");
	
		}
		
		if(!defined($nocommit)){
			$sample_id=my $result = $server->call('sampleInfo.createSample', $sqlHash);
		}
		$logger->info("Added new sample $sample_id");
	} # end of check for $irodsonly
	
	
	# register the file in the iRODs database
	
	foreach my $fobj(@filenames){
		my($f,$d,$s)=Celgene::Utils::FileFunc::fileNameParse($fobj->absFilename(),0);
		my $metadataFile="$d/$f.met";
		my $metadataStore=MetadataPrepare->new();
		
		# filetype data can be handled by the OODT MetExtractor
#		my $filetype=$metadataStore->getFileType($f);
#		foreach my $ft(@$filetype){
#			$metadataStore->addMetadata("filetype", $ft);
#		}
		$metadataStore->addMetadata("register_user", $ENV{USER});

		$metadataStore->addMetadata("sample_id",$sample_id);
		$metadataStore->addMetadata("generator",$data[ $titles{vendor}]." ".$data[ $titles{vendor_project_name}]);
		$metadataStore->addMetadata("FilePath", $fobj->absFilename());
		$metadataStore->addMetadata("FilePath", $fobj->userFileName()) if ($fobj->userFileName() ne $fobj->absFilename());	
		#$metadataStore->storeIRODS("$d/.$f.4irods");
		$logger->info("Metadata stored in $metadataFile");
		$metadataStore->storeOODT($metadataFile);
		
	}

}


$logger->info("Registration of samples in the database is completed");
@outputDirectories=Celgene::Utils::ArrayFunc::unique( \@outputDirectories );
my $scriptFn=Celgene::Utils::FileFunc::newWriteFileHandle( $file.'.register.txt');
foreach my $o(@outputDirectories){
	
	$logger->info("Please go to directory $o and run the run_crawler.sh script to ingest the files in the database");
	print $scriptFn "cd $o\nrun_crawler.sh\n";
}
$logger->info("A sample script to register the files can be found at ${file}.register.txt");
close($scriptFn);




{my $hash={};my $rhash={};
sub checkExperimentTypeCV{
	my($experiment_type)=@_;
	if(!defined($hash)){
		($hash,$rhash)= _loadHash("experiment_type_cv");
	}
	my $choise;
	if(!defined($hash->{$experiment_type})){
		print "==================================\n";
		print "Experiment type $experiment_type is not in the database.\n".
		"This field holds information on the type of the experiment \n".
		"e.g. RNA-Seq\n".
		"     ChIP-Seq\n".
		"The current list contains:\n";
		my $maxHash=_listValues($hash);
		$choise=_promptSelection( $hash, $experiment_type, $maxHash,"experiment_type_cv","experiment_type");
		if(!defined( $rhash->{$choise} )){ ($hash,$rhash)=_loadHash("experiment_type_cv"); }
	}else{
		$choise=$hash->{$experiment_type};
	}
	$experiment_type=$rhash->{  $choise  };
	
	return ($hash->{ $experiment_type } , $experiment_type);
}
}

{my $hash={};my $rhash={};
sub checkVendorCV{
	my($vendor)=@_;
	if(!defined($hash)){
		($hash,$rhash)= _loadHash("vendor_cv");
	}
	my $choise;
	if(!defined($hash->{$vendor})){
		print "==================================\n";
		print "Vendor name $vendor is not in the database. The current list contains:\n";
		my $maxHash=_listValues($hash);
		$choise=_promptSelection( $hash, $vendor, $maxHash,"vendor_cv","vendor");
		if(!defined( $rhash->{$choise} ) ){ ($hash,$rhash)=_loadHash("vendor_cv"); }

	}else{
		$choise=$hash->{$vendor};
	}
	$vendor=$rhash->{$choise};
	
	return $hash->{ $vendor };
}
}


{my $hash={};my $rhash={};
sub checkExpTypeCV{
	my($inputData, $string)=@_;
	if(!defined($hash)){
		($hash,$rhash)= _loadHash("experiment_prep_method_cv");
	}
	my $choise;
	if(!defined($hash->{$inputData})){
		print "==================================\n";
		print "Field [$inputData] for $string is not in the database.\n".
			"This field contains information on the preparation or kits used for the generation of the data\n".
			"The current list contains:\n";
		my $maxHash=_listValues($hash);
		$choise=_promptSelection( $hash, $inputData, $maxHash,"experiment_prep_method_cv","experiment_prep_method");
		if(!defined( $rhash->{$choise} ) ){ ($hash,$rhash)=_loadHash("experiment_prep_method_cv"); }
	}else{
		$choise=$hash->{$inputData};
	}
	$inputData=$rhash->{$choise};
	
	return $hash->{ $inputData };
}
}


{my $hash={};my $rhash={};
sub checkTechnologyCV{
	my($technology)=@_;
	if(!defined($hash)){
		($hash,$rhash)= _loadHash("technology_cv");
	}
	my $choise;
	if(!defined($hash->{$technology})){
		print "==================================\n";
		print "Technology $technology is not in the database.\n".
			"This field contains information on the technology or panel used for the generation of the data\n".
			"e.g. Illumina HiSeq2000, TruSeq V3\n".
			"     FMI T4 \n".
			"The current list contains:\n";
		my $maxHash=_listValues($hash);
		$choise=_promptSelection( $hash, $technology, $maxHash,"technology_cv","technology");
		if(!defined( $rhash->{$choise} ) ){ ($hash,$rhash)=_loadHash("technology_cv"); }
	}else{
		$choise=$hash->{$technology};
	}
	$technology=$rhash->{$choise};
	
	return $hash->{ $technology };
}
}

{my $hash={};my $rhash={};
sub checkCelgeneProjectDescCV{
	my($project)=@_;
	if(!defined($hash)){
		($hash,$rhash)= _loadHash("project_info");
	}
	my $choise;
	if(!defined($hash->{$project})){
		print "==================================\n";
		print "Project description $project is not in the database. The current list contains:\n";
		my $maxHash=_listValues($hash);
		$choise=_promptSelection( $hash, $project, $maxHash,"project_info","project_name");
		if(!defined( $rhash->{$choise} ) ){ ($hash,$rhash)=_loadHash("project_info"); }

	}else{
		$choise=$hash->{$project};
	}
	$project=$rhash->{$choise};
	return ($hash->{ $project }, $project);
	
}
}


sub _promptSelection{
	my($hash, $value,$maxHash,$table,$column)=@_;
	print "Would you like to add $value in the list [0] or select an existing value[1..$maxHash]?\n";
	my $choise;
	for(;;){
		$choise=<>;
		chomp $choise;
		my $numChoise=_checkNumeric($choise);
		if( defined($numChoise) and   $numChoise>=0 and $numChoise <=$maxHash){
			last;
		}
	}
	my $goldChoise;
	if($choise>0){
		print "$value will be replaced by $choise\n";
		print "==================================\n";
		$hash->{$value}=$choise;
	}else{

		$choise = $server->call( 'sampleInfo.enterCV', $table, $column, $value);
	}
	return $choise;
}

sub _listValues{
	my ($hash)=@_;	
	my $maxHash=0;
	foreach my $k( sort{ $a cmp $b }keys(%{$hash})){
		print "\t$hash->{$k}\t$k\n";
		if($maxHash<  $hash->{$k}){ $maxHash= $hash->{$k};}
	}
	return $maxHash;
}


sub _loadHash{
	my($table)=@_;

	my $result = $server->call('sampleInfo.getTableCV', $table);
	return ($result->{hash},$result->{rhash});
}

sub _checkNumeric{
	my ($v)=@_;
	my $returnValue;
	no warnings "numeric";
	$logger->debug("Checking numericity of [$v]");
	$v=~/^(\d+)$/; my $v2=$1;
	$logger->debug("Comparing [$v2] to [$v] to decide if this is a number");
	if ( defined($v2) and $v2 == $v) {
	    $returnValue= $v;
	}else{
		$logger->debug( "You have not provided a numeric value\n");
		$returnValue= undef;
	}
	return $returnValue;
}


sub getSampleId{
	my($vendor_id,$project_name)=@_;
	$logger->info("Looking for sample id from vendor_id [$vendor_id] and project [$project_name]");
	my $result = $server->call('sampleInfo.getSampleByVendorID', $vendor_id,$project_name);
	return($result->{sample_id}, 
			$result->{experiment_type_id} ,
			$result->{experiment_type},
			$result->{celgene_project_desc_id}, 
			$result->{celgene_project_desc});
}
sub getProjectId{
	my($project_name, $project_synonym)=@_;
	my $project_id = $server->call('sampleInfo.getOrCreateProjectByName', $project_name);
	my $project_id2 = $server->call('sampleInfo.getOrCreateProjectByName', $project_synonym);
	if(defined($project_synonym) ){
		$server->call('sampleInfo.createProjectSynonyms', $project_id, $project_id2);
		$logger->info("getProjectId: added synonym '$project_id2' to project '$project_id'");
	}
	
	return($project_id);
}


# list of fields that need to be added in the database with the insert query
sub databaseMandatory{
	my %hash=(
		"vendor_id"=>1,
		"vendor"=>2,
		"celgene_id"=>1,
		"experiment"=>1,
		"DA_project_id"=>1,
		"experiment_type"=>2,
		"biological_replicates_group"=>1,
		"technical_replicates_group"=>1,
		"cell_line"=>1,
		"display_name"=>1,
		"response"=>1,
		"response_desc"=>1,
		"cell_type"=>1,
		"compound"=>1,
		"dose"=>1,
		"time_treatment"=>1,
		"xenograft"=>1,
		"tissue"=>1,
		"condition"=>1,
		"antibody"=>1,
		"antibody_target"=>1,
		"stranded"=>1,
		"paired_end"=>1,
		#"celgene_project_desc"=>2,
		"filename"=>2,
		"technology"=>2,
		"stranded"=>1,
		"paired_end"=>1,
		"reference_genome"=>1,
		"host_genome"=>1
	);	
	my ($value)=@_;
	if(defined($value)){
		$value=~/(\D+)/; my $chars=$1;
		if(defined($hash{lc($value) } ) ){
			$hash{lc($value) } =2;
			return 1;
		}elsif( defined( $chars ) ){
			$hash{lc($value) } =2;
			return 1;
		}else{
			return undef;
		}
	}else{
		
		return %hash;
	}

}

# correspondence between omicssoft and postgres fields
sub omicssoft2pg{
	my %hash=(
		"cellline"=>"cell_line",
		"celltype"=>"cell_type",
		"time"=>"time_treatment",
		"biologicalreplicate"=>"biological_replicates_group",
		"technicalreplicate"=>"technical_replicates_group",
		"antibodytarget"=>"antibody_target"
	);
	my($value)=@_;
	$value=lc($value);
	if(defined($hash{$value})){
		return $hash{$value};
	}else{
		return $value;
	}
	
}



{
	my $vendor_ids={};
	my $display_names={};
	
sub validateValues{
	my($sqlHash, $line)=@_;
	my $totalWarn=0;
	my %bool=("yes"=>1, "no"=>1);
	if(!defined($sqlHash->{vendor_id}) or defined($vendor_ids->{$sqlHash->{vendor_id}}) ){ 
		
		$logger->warn("Please provide a unique vendor_id for each sample");
		$totalWarn++;
	};
	$vendor_ids->{ $sqlHash->{vendor_id} }=1;
	
	if(!defined($sqlHash->{project_id}) ){
		$logger->warn("Please provide a project_id (a name that describes the project");
		$totalWarn++;
	};

	if(!defined($sqlHash->{display_name}) or defined($display_names->{$sqlHash->{display_name}}) ){
		$logger->warn("Please provide a unique display_name for this sample");
		$totalWarn++;
	}
	$display_names->{ $sqlHash->{display_name}}=1;
	
#	$sqlHash->{response}=$data[$titles{response}];
#	$sqlHash->{cell_type}=$data[$titles{cell_type}];
#	$sqlHash->{compound_array}=\@compound_array;
#	$sqlHash->{dose_array}=\@dose_array;
#	$sqlHash->{time_treatment}=$data[$titles{time_treatment}];
	if(!defined($sqlHash->{xenograft})){
		$logger->warn("No xenograft information was provided. Assuming this dataset is not a xenograft model");
	}
	if(!defined($sqlHash->{reference_genome})){
		$logger->warn("No reference genome provided. Assumint it is Homo sapiens");
	}
	
	if(defined($sqlHash->{xenograft}) and lc($sqlHash->{xenograft}eq 'yes') and 
		!defined($sqlHash->{host_genome} )){
		$logger->warn("Athough the sample is a xenograft, there is no host genome provided");
		$totalWarn++;
	}
	if(!defined($sqlHash->{vendor_project_name})){
		$logger->warn("No vendor project name is provided. \n".
			"This is not critical but highly recommended to add");
	}
	if(!defined($sqlHash->{ technology}) ){
		$logger->warn("No technology was provided (e.g. Illumina HiSeq 2000 etc");
		$totalWarn ++;
	}
	
	if(!defined($sqlHash->{experiment_type})){
		$logger->warn("No experiment type was provided (e.g. RNA-Seq, ChIP-Seq etc");
		$totalWarn++;
	}
	if(!defined($sqlHash->{vendor})){
		$logger->warn("No vendor provided");
		$totalWarn ++;
	}
	if($sqlHash->{experiment_type} eq 'ChIP-Seq' and
		!defined($sqlHash->{antibody}) or 
		!defined($sqlHash->{antibody_target})){
			$logger->warn("Despite being a ChIP-Seq experiment no antibody information is provided");
			$totalWarn ++;
		}
	my %stranded=( "NONE"=>1, "REVERSE"=>1,"FORWARD"=>1 );
	$sqlHash->{stranded}=uc($sqlHash->{stranded});
	if(!defined($sqlHash->{stranded}) or !defined($stranded{$sqlHash->{stranded}} )){
		$logger->warn("Stranded information was not provided.".
			"Please make sure it is one of 'NONE','FORWARD','REVERSE'\n");
			$totalWarn++;	
	}
	$sqlHash->{paired_end}=lc($sqlHash->{paired_end});
	if(!defined( $sqlHash->{paired_end} ) or !defined($bool{$sqlHash->{paired_end} })){
		
		$logger->warn("Paired end information was not provided.".
			"Please make sure it is one of 'yes', 'no'\n");
			$totalWarn++;	
	}
	if($totalWarn >0){
		$logger->warn("Line: $line");
		$logger->logdie("Cannot proceed unless the previous warnings have been fixed");
	}
	
}	
}
